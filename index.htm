<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Codah — conversational console</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self'; style-src 'unsafe-inline' 'self'; connect-src 'self' https:; img-src 'self' data:; frame-ancestors 'none'; base-uri 'none'">
  <style>
    :root{
      color-scheme:light;
      font-family:"Inter", "Segoe UI", Roboto, system-ui, -apple-system, sans-serif;
      --bg:#eef1f7;
      --panel:#ffffff;
      --panel-border:#d7deed;
      --muted:#6b7285;
      --primary:#2b6bff;
      --primary-dark:#184dce;
      --accent:#eff4ff;
      --shadow:0 24px 60px rgba(15,40,96,0.12);
    }
    *,*::before,*::after{box-sizing:border-box}
    body{margin:0;min-height:100vh;background:var(--bg);display:flex;align-items:center;justify-content:center;padding:32px;color:#111827}
    .stage{width:100%;display:flex;justify-content:center}
    .console{background:var(--panel);border:1px solid var(--panel-border);border-radius:36px;box-shadow:var(--shadow);padding:28px;display:flex;flex-direction:column;gap:24px;width:min(460px,92vw);min-height:640px}
    .toolbar{display:flex;align-items:flex-start;justify-content:space-between;gap:12px}
    .toolbar-brand{display:flex;gap:14px;align-items:flex-start}
    .brand-glow{width:14px;height:14px;border-radius:50%;background:radial-gradient(circle at center,#43d3ff,#2b6bff);box-shadow:0 0 16px rgba(43,107,255,0.45);margin-top:6px}
    .brand-copy{display:flex;flex-direction:column;gap:4px}
    .brand-title{font-size:1.05rem;font-weight:600;letter-spacing:0.02em;color:#0f172a}
    .toolbar-controls{display:flex;gap:10px}
    .chip{border:none;border-radius:999px;background:var(--primary);color:#fff;font-size:0.82rem;font-weight:600;padding:9px 20px;cursor:pointer;box-shadow:0 12px 24px rgba(43,107,255,0.28);transition:transform .2s ease,box-shadow .2s ease}
    .chip:focus-visible{outline:none;box-shadow:0 0 0 3px rgba(43,107,255,0.45)}
    .chip:active{transform:translateY(1px)}
    .chip[aria-pressed="true"]{background:var(--primary-dark)}
    .chat-surface{flex:1;background:#f8faff;border-radius:28px;border:1px solid var(--panel-border);padding:24px;display:flex}
    .chat-log{flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:18px;scrollbar-width:thin;scrollbar-color:#c3d0ea transparent}
    .chat-log::-webkit-scrollbar{width:6px}
    .chat-log::-webkit-scrollbar-track{background:transparent}
    .chat-log::-webkit-scrollbar-thumb{background:#c3d0ea;border-radius:999px}
    .empty-state{margin:0 auto;color:var(--muted);font-size:0.9rem;padding-top:36px;text-align:center;max-width:240px}
    .message{display:grid;gap:6px;max-width:88%}
    .message-role{font-size:0.7rem;text-transform:uppercase;letter-spacing:0.1em;color:#9aa3b7}
    .message-bubble{margin:0;padding:14px 18px;border-radius:20px;line-height:1.55;background:#fff;border:1px solid rgba(209,218,236,0.9);color:#1b2337;box-shadow:0 16px 32px rgba(15,40,96,0.08)}
    .message-user{margin-left:auto;text-align:right}
    .message-user .message-role{color:#89a8ff}
    .message-user .message-bubble{background:var(--primary);color:#fff;border:none;border-bottom-right-radius:8px}
    .message-assistant .message-bubble{border-radius:20px;border-bottom-left-radius:8px}
    .message-system .message-bubble{font-style:italic;background:#f2f4fb;color:#4c566a;border-style:dashed}
    .composer{display:flex;flex-direction:column;gap:16px}
    .composer input[type="text"]{width:100%;border:1px solid var(--panel-border);border-radius:18px;padding:16px 20px;font-size:1rem;background:#f9fbff;color:#111827;transition:border-color .2s ease,box-shadow .2s ease}
    .composer input[type="text"]:focus-visible{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px rgba(43,107,255,0.28);background:#fff}
    .composer input[type="text"]:disabled{background:#e8edf8;color:#6b7285}
    .actions{display:flex;gap:10px;flex-wrap:wrap}
    .action{flex:1 1 30%;display:inline-flex;justify-content:center;align-items:center;border:none;border-radius:999px;background:var(--primary);color:#fff;font-weight:600;padding:12px 18px;cursor:pointer;box-shadow:0 14px 30px rgba(43,107,255,0.25);transition:transform .2s ease,box-shadow .2s ease}
    .action:focus-visible{outline:none;box-shadow:0 0 0 3px rgba(43,107,255,0.45)}
    .action:active{transform:translateY(1px)}
    .action:is(:disabled,.is-disabled){background:#9bb5ff;color:#f1f5ff;cursor:not-allowed;box-shadow:none}
    .action.is-active{background:var(--primary-dark)}
    .attachments-preview{display:flex;flex-direction:column;gap:10px;border-radius:16px;background:#eef3ff;border:1px dashed rgba(96,127,255,0.4);padding:12px 16px;transition:opacity .2s ease}
    .attachments-preview.is-empty{display:none}
    .attachments-title{margin:0;font-size:0.8rem;font-weight:600;letter-spacing:0.05em;color:#44527a;text-transform:uppercase}
    .attachments-list{margin:0;list-style:none;padding:0;display:flex;flex-direction:column;gap:8px}
    .attachments-item{display:flex;justify-content:space-between;align-items:center;gap:12px;font-size:0.85rem;color:#1b2337;background:#fff;border-radius:12px;padding:10px 14px;border:1px solid rgba(66,104,198,0.25)}
    .attachments-meta{display:flex;flex-direction:column;gap:4px}
    .attachments-name{font-weight:600;font-size:0.88rem;color:#1b2337}
    .attachments-size{font-size:0.75rem;color:#6b7285}
    .attachments-remove{border:none;border-radius:8px;padding:6px 10px;font-size:0.75rem;font-weight:600;background:#d92c3b;color:#fff;cursor:pointer;transition:opacity .2s ease}
    .attachments-remove:hover{opacity:0.85}
    .status{min-height:1.3rem;font-size:0.85rem;margin:0;color:var(--muted)}
    .status[data-tone="success"]{color:#1c8f4d}
    .status[data-tone="error"]{color:#d02938}
    .status[data-tone="warn"]{color:#cc7a00}
    .sr-only{position:absolute;clip:rect(0 0 0 0);clip-path:inset(50%);height:1px;width:1px;overflow:hidden;white-space:nowrap;border:0;padding:0}
    @media (max-width:520px){
      body{padding:16px}
      .console{padding:22px;border-radius:28px;min-height:520px}
      .chat-surface{padding:18px;border-radius:24px}
      .actions{flex-direction:column}
      .action{width:100%}
    }
  </style>
</head>
<body>
  <main class="stage">
    <section class="console" role="application" aria-label="Codah conversational console">
      <header class="toolbar">
        <div class="toolbar-brand">
          <span class="brand-glow" aria-hidden="true"></span>
          <div class="brand-copy">
            <span class="brand-title">Codah Console</span>
          </div>
        </div>
        <div class="toolbar-controls">
          <button type="button" class="chip" id="lang-toggle" aria-label="Switch language">EN</button>
          <button type="button" class="chip" id="mute-toggle" aria-pressed="false">Mute</button>
        </div>
      </header>

      <div class="chat-surface">
        <div class="chat-log" id="log" role="log" aria-live="polite" aria-label="Conversation transcript">
          <p class="empty-state" id="empty-state">Say hello to start a conversation.</p>
        </div>
      </div>

      <form class="composer" id="composer" autocomplete="off">
        <label class="sr-only" for="msg">Message</label>
        <input id="msg" name="message" type="text" inputmode="text" placeholder="hello" autocomplete="off">
        <div class="actions">
          <button type="submit" class="action primary" id="send">Send</button>
          <button type="button" class="action" id="record" aria-pressed="false">Record</button>
          <button type="button" class="action" id="upload">Upload</button>
        </div>
        <div class="attachments-preview is-empty" id="attachments" aria-live="polite"></div>
        <p class="status" id="status" role="status" aria-live="polite"></p>
      </form>

      <input type="file" id="file-upload" class="sr-only" accept="audio/*,.txt,.md,.pdf,image/*" tabindex="-1" aria-hidden="true">
    </section>
  </main>

  <script>
    const translations = {
      en: {
        emptyState: 'Say hello to start a conversation.',
        placeholder: 'Type your message',
        send: 'Send',
        recordStart: 'Record',
        recordStop: 'Stop',
        upload: 'Upload',
        languageSet: 'Language set to {code}.',
        muteOn: 'Notifications muted.',
        muteOff: 'Notifications active.',
        muteLabelOn: 'Mute',
        muteLabelOff: 'Unmute',
        sending: 'Sending…',
        delivered: 'Delivered',
        responseReceived: 'Response received',
        requestFailed: 'Request failed',
        networkError: 'Network error',
        typePrompt: 'Type a message to begin.',
        recording: 'Recording…',
        recordReady: 'Recording captured.',
        recordReadyDetail: 'Voice recorder stopped and audio attached.',
        recordError: 'Recording unavailable.',
        recordErrorDetail: 'Could not capture audio from this device.',
        recordingUnsupported: 'Recording is not supported in this browser.',
        voiceArmed: 'Voice recorder armed — capturing audio preview.',
        voiceStopped: 'Voice recorder stopped. Audio attached for sending.',
        uploadReady: 'Attachment ready: {name}',
        uploadReadyDetail: 'Attached {name} ({size} KB).',
        uploadTooLarge: 'File exceeds attachment limit.',
        uploadUnsupported: 'File type is not supported.',
        attachmentLimit: 'Attachment limit reached.',
        attachmentRemoved: '{name} removed.',
        attachmentsHeading: 'Attachments ready:',
        gatewayConfigured: 'Using gateway {url}.'
      },
      es: {
        emptyState: 'Saluda para iniciar una conversación.',
        placeholder: 'Escribe tu mensaje',
        send: 'Enviar',
        recordStart: 'Grabar',
        recordStop: 'Detener',
        upload: 'Adjuntar',
        languageSet: 'Idioma configurado a {code}.',
        muteOn: 'Notificaciones silenciadas.',
        muteOff: 'Notificaciones activas.',
        muteLabelOn: 'Silenciar',
        muteLabelOff: 'Activar sonido',
        sending: 'Enviando…',
        delivered: 'Entregado',
        responseReceived: 'Respuesta recibida',
        requestFailed: 'Solicitud fallida',
        networkError: 'Error de red',
        typePrompt: 'Escribe un mensaje para comenzar.',
        recording: 'Grabando…',
        recordReady: 'Grabación capturada.',
        recordReadyDetail: 'Grabadora detenida y audio adjunto.',
        recordError: 'Grabación no disponible.',
        recordErrorDetail: 'No se pudo capturar audio en este dispositivo.',
        recordingUnsupported: 'El navegador no admite la grabación.',
        voiceArmed: 'Grabadora activada: capturando vista previa.',
        voiceStopped: 'Grabadora detenida. Audio adjunto para enviar.',
        uploadReady: 'Adjunto listo: {name}',
        uploadReadyDetail: 'Se adjuntó {name} ({size} KB).',
        uploadTooLarge: 'El archivo excede el límite permitido.',
        uploadUnsupported: 'Tipo de archivo no admitido.',
        attachmentLimit: 'Se alcanzó el límite de adjuntos.',
        attachmentRemoved: '{name} eliminado.',
        attachmentsHeading: 'Adjuntos listos:',
        gatewayConfigured: 'Usando gateway {url}.'
      }
    };

    const ATTACHMENT_TYPES = new Set([
      'audio/webm',
      'audio/mp4',
      'audio/mpeg',
      'audio/wav',
      'text/plain',
      'text/markdown',
      'application/pdf',
      'image/png',
      'image/jpeg'
    ]);

    const MAX_ATTACHMENT_BYTES = 1048576;
    const MAX_ATTACHMENTS = 3;

    const EXTENSION_MIME_MAP = {
      md: 'text/markdown',
      markdown: 'text/markdown',
      txt: 'text/plain',
      text: 'text/plain',
      pdf: 'application/pdf',
      png: 'image/png',
      jpg: 'image/jpeg',
      jpeg: 'image/jpeg',
      mp3: 'audio/mpeg',
      wav: 'audio/wav',
      m4a: 'audio/mp4',
      webm: 'audio/webm'
    };

    const STORAGE_KEYS = { lang: 'codah-console-lang' };

    function resolveGatewayUrl(){
      const search = new URLSearchParams(window.location.search);
      const fromQuery = search.get('gateway');
      const fromGlobal = window.__GATEWAY_URL__ || '';
      const fromMeta = document.querySelector('meta[name="codah-gateway"]')?.content || '';
      const fallback = new URL('/v1/gateway', window.location.origin).href;
      const candidate = fromQuery || fromGlobal || fromMeta || fallback;
      try{
        const url = new URL(candidate, window.location.origin);
        if(url.protocol !== 'https:' && url.origin !== window.location.origin){
          throw new Error('insecure');
        }
        return url.href;
      }catch(err){
        console.warn('Invalid gateway url, using default', err);
        return fallback;
      }
    }

    const GATEWAY_URL = resolveGatewayUrl();
    const DEFAULT_PROVIDER = 'atlas';

    const $ = (id) => document.getElementById(id);
    const state = {
      lang: localStorage.getItem(STORAGE_KEYS.lang) || 'en',
      muted: false,
      recording: false,
      attachments: [],
      mediaRecorder: null,
      mediaStream: null
    };

    const composer = $('composer');
    const msgInput = $('msg');
    const sendBtn = $('send');
    const statusEl = $('status');
    const log = $('log');
    let emptyState = $('empty-state');
    const langToggle = $('lang-toggle');
    const muteToggle = $('mute-toggle');
    const recordBtn = $('record');
    const uploadBtn = $('upload');
    const uploadInput = $('file-upload');
    const attachmentsEl = $('attachments');

    function t(key, replacements = {}){
      const dict = translations[state.lang] || translations.en;
      let phrase = dict[key];
      if(!phrase){
        phrase = translations.en[key];
      }
      if(!phrase){
        return key;
      }
      return phrase.replace(/\{(\w+)\}/g, (_, token) => {
        return Object.prototype.hasOwnProperty.call(replacements, token) ? replacements[token] : `{${token}}`;
      });
    }

    function setStatus(message = '', tone = 'info', replacements = {}){
      if(!statusEl){ return; }
      const resolved = translations[state.lang]?.[message] || translations.en?.[message] || message;
      statusEl.textContent = resolved.replace(/\{(\w+)\}/g, (_, token) => {
        return Object.prototype.hasOwnProperty.call(replacements, token) ? replacements[token] : `{${token}}`;
      });
      statusEl.dataset.tone = tone;
    }

    function clearEmptyState(){
      if(emptyState){
        emptyState.remove();
        emptyState = null;
      }
    }

    function createMessage(role, text){
      const article = document.createElement('article');
      article.className = `message message-${role}`;
      const label = document.createElement('span');
      label.className = 'message-role';
      label.textContent = role === 'user' ? 'You' : role === 'assistant' ? 'Codah' : 'System';
      const bubble = document.createElement('p');
      bubble.className = 'message-bubble';
      bubble.textContent = text;
      article.append(label, bubble);
      return article;
    }

    function appendMessage(role, text){
      if(!log){ return; }
      clearEmptyState();
      log.appendChild(createMessage(role, text));
      log.scrollTo({ top: log.scrollHeight, behavior: 'smooth' });
    }

    function normalize(value){
      return value.normalize('NFKC').replace(/[^\S\r\n]+/g,' ').trim();
    }

    function updateLanguageUI(){
      document.documentElement.lang = state.lang;
      if(msgInput){
        msgInput.placeholder = t('placeholder');
      }
      if(sendBtn){
        sendBtn.textContent = t('send');
      }
      if(recordBtn){
        recordBtn.textContent = state.recording ? t('recordStop') : t('recordStart');
      }
      if(uploadBtn){
        uploadBtn.textContent = t('upload');
      }
      if(langToggle){
        langToggle.textContent = state.lang.toUpperCase();
        langToggle.setAttribute('aria-label', `Language ${state.lang.toUpperCase()}`);
      }
      if(muteToggle){
        muteToggle.textContent = state.muted ? t('muteLabelOff') : t('muteLabelOn');
      }
      if(emptyState){
        emptyState.textContent = t('emptyState');
      }
      renderAttachments();
    }

    function sanitizeFileName(name){
      return (name || 'attachment')
        .replace(/[^\w.\-\s]/g, '')
        .replace(/\s+/g, ' ')
        .trim()
        .slice(0, 128) || 'attachment';
    }

    function totalAttachmentBytes(){
      return state.attachments.reduce((sum, item) => sum + (item.size || 0), 0);
    }

    function renderAttachments(){
      if(!attachmentsEl){ return; }
      attachmentsEl.innerHTML = '';
      if(!state.attachments.length){
        attachmentsEl.classList.add('is-empty');
        return;
      }
      attachmentsEl.classList.remove('is-empty');
      const title = document.createElement('p');
      title.className = 'attachments-title';
      title.textContent = t('attachmentsHeading');
      const list = document.createElement('ul');
      list.className = 'attachments-list';
      state.attachments.forEach((item, index) => {
        const li = document.createElement('li');
        li.className = 'attachments-item';
        const meta = document.createElement('div');
        meta.className = 'attachments-meta';
        const name = document.createElement('span');
        name.className = 'attachments-name';
        name.textContent = item.name;
        const size = document.createElement('span');
        size.className = 'attachments-size';
        size.textContent = `${Math.max(1, Math.round((item.size || 0) / 1024))} KB`;
        meta.append(name, size);
        const remove = document.createElement('button');
        remove.type = 'button';
        remove.className = 'attachments-remove';
        remove.textContent = '×';
        remove.setAttribute('aria-label', `Remove ${item.name}`);
        remove.addEventListener('click', () => {
          state.attachments.splice(index, 1);
          renderAttachments();
          setStatus('attachmentRemoved', 'info', { name: item.name });
        });
        li.append(meta, remove);
        list.appendChild(li);
      });
      attachmentsEl.append(title, list);
    }

    function ensureAttachmentCapacity(size){
      if(state.attachments.length >= MAX_ATTACHMENTS){
        setStatus('attachmentLimit', 'warn');
        return false;
      }
      if((totalAttachmentBytes() + size) > MAX_ATTACHMENT_BYTES){
        setStatus('uploadTooLarge', 'warn');
        return false;
      }
      return true;
    }

    async function queueAttachment(file){
      let type = file.type || '';
      if(type.includes(';')){ type = type.split(';')[0]; }
      if(type){ type = type.toLowerCase(); }
      if(!type){
        const ext = file.name.split('.').pop()?.toLowerCase() || '';
        type = EXTENSION_MIME_MAP[ext] || 'application/octet-stream';
      }
      if(ATTACHMENT_TYPES.size && !ATTACHMENT_TYPES.has(type)){
        setStatus('uploadUnsupported', 'warn');
        return;
      }
      const buffer = await file.arrayBuffer();
      const size = buffer.byteLength;
      if(size > MAX_ATTACHMENT_BYTES){
        setStatus('uploadTooLarge', 'warn');
        return;
      }
      if(!ensureAttachmentCapacity(size)){
        return;
      }
      const data = arrayBufferToBase64(buffer);
      const safeName = sanitizeFileName(file.name);
      state.attachments.push({ name: safeName, type, data, size });
      renderAttachments();
      setStatus('uploadReady', 'success', { name: safeName });
      appendMessage('system', t('uploadReadyDetail', { name: safeName, size: Math.max(1, Math.round(size / 1024)) }));
    }

    function arrayBufferToBase64(buffer){
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for(let i = 0; i < len; i += 4096){
        const chunk = bytes.subarray(i, Math.min(i + 4096, len));
        binary += String.fromCharCode(...chunk);
      }
      return btoa(binary);
    }

    async function sendMessage(){
      if(!msgInput || !sendBtn){ return; }
      const text = normalize(msgInput.value || '');
      if(!text){
        setStatus('typePrompt', 'warn');
        msgInput.focus();
        return;
      }

      appendMessage('user', text);
      msgInput.value = '';
      msgInput.focus();

      const provider = DEFAULT_PROVIDER;
      const payload = {
        provider,
        message: text,
        lang: state.lang,
        honeypot: '',
        attachments: state.attachments.slice()
      };

      sendBtn.disabled = true;
      msgInput.disabled = true;
      setStatus('sending');

      try{
        const headers = { 'Content-Type': 'application/json' };
        const traceId = (window.crypto && typeof window.crypto.randomUUID === 'function') ? window.crypto.randomUUID() : null;
        if(traceId){ headers['X-Trace-Id'] = traceId; }
        const res = await fetch(GATEWAY_URL, {
          method: 'POST',
          headers,
          body: JSON.stringify(payload)
        });

        const data = await res.json().catch(() => ({ error: 'Unable to parse response.' }));
        const ok = res.ok && !data.error;
        const content = data.text || data.message || data.output;

        if(ok && content){
          appendMessage('assistant', content);
          setStatus('delivered', 'success');
          state.attachments = [];
          renderAttachments();
        }else if(ok){
          appendMessage('assistant', JSON.stringify(data, null, 2));
          setStatus('responseReceived', 'success');
          state.attachments = [];
          renderAttachments();
        }else{
          appendMessage('system', data.error || `${res.status} ${res.statusText}`);
          setStatus('requestFailed', 'error');
        }
      }catch(err){
        const message = err instanceof Error ? err.message : 'Network error';
        appendMessage('system', message);
        setStatus('networkError', 'error');
      }finally{
        sendBtn.disabled = false;
        msgInput.disabled = false;
        msgInput.focus();
      }
    }

    async function startRecording(){
      if(!navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== 'function' || typeof MediaRecorder === 'undefined'){
        if(recordBtn){
          recordBtn.disabled = true;
          recordBtn.classList.add('is-disabled');
        }
        setStatus('recordingUnsupported', 'warn');
        return;
      }
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        state.mediaStream = stream;
        state.mediaRecorder = new MediaRecorder(stream);
        const chunks = [];
        state.mediaRecorder.addEventListener('dataavailable', (event) => {
          if(event.data && event.data.size){
            chunks.push(event.data);
          }
        });
        state.mediaRecorder.addEventListener('stop', async () => {
          const blob = new Blob(chunks, { type: state.mediaRecorder.mimeType || 'audio/webm' });
          stream.getTracks().forEach((track) => track.stop());
          state.mediaStream = null;
          state.mediaRecorder = null;
          state.recording = false;
          recordBtn?.classList.remove('is-active');
          recordBtn?.setAttribute('aria-pressed', 'false');
          recordBtn.textContent = t('recordStart');
          try{
            const baseName = `voice-${Date.now()}.webm`;
            const normalizedType = (blob.type || 'audio/webm').split(';')[0].toLowerCase();
            const file = new File([blob], baseName, { type: normalizedType });
            await queueAttachment(file);
            setStatus('recordReady', 'success');
            appendMessage('system', t('voiceStopped'));
          }catch(error){
            setStatus('recordError', 'error');
            appendMessage('system', t('recordErrorDetail'));
          }
        });
        state.mediaRecorder.start();
        state.recording = true;
        recordBtn?.classList.add('is-active');
        recordBtn?.setAttribute('aria-pressed', 'true');
        recordBtn.textContent = t('recordStop');
        setStatus('recording');
        appendMessage('system', t('voiceArmed'));
      }catch(error){
        setStatus('recordError', 'error');
        appendMessage('system', t('recordErrorDetail'));
      }
    }

    function stopRecording(){
      if(state.mediaRecorder && state.recording){
        state.mediaRecorder.stop();
      }
    }

    if(composer){
      composer.addEventListener('submit', (event) => {
        event.preventDefault();
        sendMessage();
      });
    }

    if(sendBtn){
      sendBtn.addEventListener('click', (event) => {
        event.preventDefault();
        sendMessage();
      });
    }

    if(msgInput){
      msgInput.addEventListener('keydown', (event) => {
        if(event.key === 'Enter' && !event.shiftKey){
          event.preventDefault();
          sendMessage();
        }
      });
    }

    if(langToggle){
      langToggle.addEventListener('click', () => {
        state.lang = state.lang === 'en' ? 'es' : 'en';
        try{ localStorage.setItem(STORAGE_KEYS.lang, state.lang); }catch{}
        setStatus('languageSet', 'info', { code: state.lang.toUpperCase() });
        updateLanguageUI();
      });
    }

    if(muteToggle){
      muteToggle.textContent = state.muted ? t('muteLabelOff') : t('muteLabelOn');
      muteToggle.setAttribute('aria-pressed', String(state.muted));
      if(log){ log.setAttribute('aria-live', state.muted ? 'off' : 'polite'); }
      muteToggle.addEventListener('click', () => {
        state.muted = !state.muted;
        muteToggle.setAttribute('aria-pressed', String(state.muted));
        muteToggle.textContent = state.muted ? t('muteLabelOff') : t('muteLabelOn');
        if(log){ log.setAttribute('aria-live', state.muted ? 'off' : 'polite'); }
        setStatus(state.muted ? 'muteOn' : 'muteOff');
      });
    }

    if(recordBtn){
      recordBtn.addEventListener('click', async () => {
        if(state.recording){
          stopRecording();
        }else{
          await startRecording();
        }
      });
    }

    if(uploadBtn && uploadInput){
      uploadBtn.addEventListener('click', () => {
        uploadInput.click();
      });

      uploadInput.addEventListener('change', () => {
        if(uploadInput.files && uploadInput.files.length){
          const file = uploadInput.files[0];
          queueAttachment(file);
        }
        uploadInput.value = '';
      });
    }

    updateLanguageUI();
    setStatus('gatewayConfigured', 'info', { url: new URL(GATEWAY_URL).hostname });
  </script>
</body>
</html>
